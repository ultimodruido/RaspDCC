#include <xc.h>
#include <stdint.h>
#include "PICconfig.h"
#include "PICinit.h"

// rename CCP1 output as DCC_TRACK_COMMAND
#define DCC_TRACK_COMMAND_WRITE LATAbits.LATA5
#define DCC_TRACK_COMMAND_READ PORTAbits.RA5

// RA0 is connected to the enable pin of the MOSFETs
#define DCC_COMMAND_ENABLE LATAbits.LATA0

// RA3 is connected to the emergency pushbutton
#define PUSH_BUTTON_EMERGENCY PORTAbits.RA3

// RA4 is connected with Rapoberry GPIO0
#define PI_FEEDBACK LATAbits.LATA4

// configure the I2C address for comunication
#define I2C_slave_address 0x30

// definition of DCC semiwave HI and LOW duration (us)
#define DCC_LO  58
#define DCC_HI  100

// simy wave of 10ms (10000us = 0h2710)
#define DCC_PAUSE_MSB 0x27
#define DCC_PAUSE_LSB 0x10

// set max number of bouffers for I2C
#define I2C_index_array_max 32
// DCC standard needs at most 4 byte per package
#define DCC_index_array_max 4 

// set the array for 8 different buffers
// (4 bytes long) to be used with I2C
volatile uint8_t I2C_RX_array[I2C_index_array_max][DCC_index_array_max] = 0;
// marker to save how many bytes have been send by the master
volatile uint8_t I2C_RX_array_usage[I2C_index_array_max] = 0;

// prepare variable used to work through the received and transmitted data
volatile uint8_t I2C_index_array = 0;
volatile uint8_t I2C_index_pkg_byte = 0;
uint8_t DCC_index_read = 0;


// creation of bit accessed controlling variable for DDC
volatile union {
    uint8_t command;

    struct {
        unsigned DCC_INT : 1;
        unsigned DCC_PAUSE_RUN : 1;
        unsigned DELAYED_POLARITY_CHANGE : 1;
    };
} DCCCON;

// function declarations
void DCC_send_bit(uint8_t);

/******* MAIN ROUTINE *******/
int main(void) {

    // create some control variables
    uint8_t index = 0;
    uint8_t index2 = 0;

    // call function for registers set up
    initialize(I2C_slave_address);

    // initialize DCCON - reset INT bit and set PAUSE_RUN
    DCCCON.DCC_INT = 1;
    DCCCON.DCC_PAUSE_RUN = 1;
    DCCCON.DELAYED_POLARITY_CHANGE = 0;

    // TODO use delay function to pause 1s to enable the circuit to stabilize
    // before any DCC signal is transmitted to the rail track
    // with 16 MHz -> 4 instruction per us
    // 1s = 1'000'000 us



    // set CCP1 value for compare to DCC_PAUSE status
    CCPR1H = DCC_PAUSE_MSB;
    CCPR1L = DCC_PAUSE_LSB;

    //reset Timer1 - NOW COUNTING STARTS
    TMR1H = 0;
    TMR1L = 0;

    // here starts the infinite loop
    for (;;) {

        // ENABLE control. if NOT ENABLE skip DCC transmission.
        if (PUSH_BUTTON_EMERGENCY) {
            DCC_COMMAND_ENABLE = 1;
        } else {
            DCC_COMMAND_ENABLE = 0;
        }

        if (DCC_COMMAND_ENABLE) {

            // DCC transmit is started only if the I2C is ready to write the next array.
            // This if statement checks if I2C_index_array is higher than DCC_index_read
            // including some additional check to fit the return to the array start
            if ((DCC_index_read < I2C_index_array) || ((DCC_index_read == I2C_index_array_max - 1) && (I2C_index_array == 0))) {

                // send the raspberry a feedback that DCC transmission is ON
                PI_FEEDBACK = 1;

                // reset DCC_PAUSE flag so the short wave can be
                // generated by cature and compare module
                DCCCON.DCC_PAUSE_RUN = 0;

                // reset the delayed polarity change
                DCCCON.DELAYED_POLARITY_CHANGE = 0;

                // send preambel (>11bit HI)
                for (index = 0; index < 12; index++) {
                    DCC_send_bit(DCC_HI);
                }

                // send start bit (1 bit LO)
                DCC_send_bit(DCC_LO);

                // for cycle to send all received bytes
                // separated by 1 bit LO
                for (index = 0; index <= I2C_RX_array_usage[DCC_index_read]; index++) {

                    // for cycle for each bit in byte
                    // transmit from MSB (bit 7) to LSB (bit 0)
                    for (index2 = 0; index2 < 8; index2++) {
                        if (I2C_RX_array[DCC_index_read][I2C_index_pkg_byte] & (0b10000000 >> index2)) {
                            DCC_send_bit(DCC_HI);
                        } else {
                            DCC_send_bit(DCC_LO);
                        }
                    }

                    // byte transmission completed
                    // send bit 0 (LO) at the end of each byte
                    DCC_send_bit(DCC_LO);

                }

                // send error byte (XOR of all bytes):
                // calculare XOR byte in first byte of the array, it is anyway
                // itself if only one byte has to be sent, no need to use additional
                // variable. The complete content has already been sent and will be
                // overwritten in the future
                for (index = 1; index <= I2C_RX_array_usage[DCC_index_read]; index++) {
                    I2C_RX_array[DCC_index_read][0] = I2C_RX_array[DCC_index_read][0] ^ I2C_RX_array[DCC_index_read][index];
                }

                // transmit XOR byte from MSB (bit 7) to LSB (bit 0)
                for (index2 = 0; index2 < 8; index2++) {
                    if (I2C_RX_array[DCC_index_read][0] & (0b10000000 >> index2)) {
                        DCC_send_bit(DCC_HI);
                    } else {
                        DCC_send_bit(DCC_LO);
                    }
                }

                // send stop bit (1 bit HI)
                DCC_send_bit(DCC_HI);

                // clear buffers
                for (index = 0; index <= I2C_RX_array_usage[DCC_index_read]; index++) {
                    I2C_RX_array[DCC_index_read][index] = 0;
                }

                // send the raspberry a feedback that DCC transmission is OFF
                PI_FEEDBACK = 0;


                // increase value for DCC_index_read so that the next
                // can be transmitted. Only if no delay in the polarity
                // change has been identified. If yes better transmit this again
                if (!DCCCON.DELAYED_POLARITY_CHANGE) {
                    DCC_index_read++;
                }

            }// end of if( (DCC_index_read < I2C_index_array)...
            else {
                // wait 6 instruction (if clock 16MHz -> 1.5us)
                // don't wait anything. keep switchung every 10ms
                // To reach 10 ms CCPR1H has to set to DCC_PAUSE_MSB.
                // a different routine similar to DCC_send_bit
                // will be createdto be create
                DCCCON.DCC_PAUSE_RUN = 1;
                DCC_send_bit(DCC_PAUSE_LSB);
            }

        } // enf of if (DCC_COMMAND_ENABLE)
        else {
            _delay(100);
        } // enf of if (DCC_COMMAND_ENABLE)

        // clear watch dog counter
        CLRWDT();

    } // end of infinite loop

    return 0;
}

/******* DCC_send_bit ROUTINE *******/
void DCC_send_bit(uint8_t semi_period) {
    // wait for DCCCON.DCC_INT = 1 which means:
    // wait that the previous wave transmission is completed
    while (!DCCCON.DCC_INT) {
        _delay(6);
    }

    // reset DCCCON.DCC_INT flag
    DCCCON.DCC_INT = 0;

    // check if we are in PAUSE MODE (no signal to be transferred)
    // high byte of CCP1 has to be set
    if (DCCCON.DCC_PAUSE_RUN) {
        CCPR1H = DCC_PAUSE_MSB;
    } else {
        CCPR1H = 0;
    }
    //set compare value for CCP1 low byte
    CCPR1L = semi_period;

    // wait for the first semiwave to be transmitted
    while (!DCCCON.DCC_INT) {
        _delay(6);
    }

    // reset DCCCON.DCC_INT flag, so that the second semiwave properly starts
    DCCCON.DCC_INT = 0;
}

/******* INTERRUPT ROUTINE *******/
void interrupt ISR(void) {
    // Timer1/Compare1 interrupt that controls DDC command
    if (PIR1bits.CCP1IF) {
        // invert command on DCC_TRACK
        DCC_TRACK_COMMAND_WRITE = ~DCC_TRACK_COMMAND_READ;
        //asm(?btfss	LATA,5?);
        /*#asm // like this...
            btfss	LATA,5	;volatile
            bsf         LATA,5	;volatile
            bcf         LATA,5	;volatile
        #endasm */
        // check if timer counted more that 5us. If Yes polarity
        // inversion is probably out of tolerance
        if (TMR1L >= 5) {
            DCCCON.DELAYED_POLARITY_CHANGE = 1;
        }

        //record flag of ISR timer accessed
        DCCCON.DCC_INT = 1;
        // clear CCP1 interrrupt flag
        PIR1bits.CCP1IF = 0;
    }

    // I2C interrupt
    if (PIR1bits.SSP1IF) {
        if (!SSPSTATbits.R_nW) { // Raspberry is sending infos
            if (SSPSTATbits.P) {
                // save array length for transmission to track
                I2C_RX_array_usage[I2C_index_array] = I2C_index_pkg_byte - 1;

                // increase index of I2C_index_array
                I2C_index_array++;
                if (I2C_index_array == I2C_index_array_max) {
                    I2C_index_array = 0;
                }

                // reset I2C_index_pkg_byte for the mext transmission
                I2C_index_pkg_byte = 0;

            } else {
                if (!SSPSTATbits.D_nA) { // address byte received
                    // read SSPBUT to clear SSPSTAT.BF bit will be overwritten
                    // when data byte arrives
                    I2C_RX_array[I2C_index_array][I2C_index_pkg_byte] = SSPBUF;

                    SSP1CON1bits.CKP = 1; // release slock stretch
                }
                else { // data byte received
                    // save the received data in the right place :)
                    I2C_RX_array[I2C_index_array][I2C_index_pkg_byte] = SSPBUF;
                    // increase the index for byte
                    I2C_index_pkg_byte++;
                    SSP1CON1bits.CKP = 1; // release slock stretch
                }
            }
        }
        PIR1bits.SSP1IF = 0;
    } // end of I2C interrupt

}

